package queenproject;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
/**
 *
 * @author Andre
 */
public class queenPuzzle {
   private int [][]board = new int[15][15];
   private String label = "";
   private int age;
   
   public queenPuzzle(){
       age = 0;
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               board[i][j] = 0;
           }
       }
       
       List<Integer> queens = new ArrayList<Integer>();
       
       for(int i = 0; i < 15; i++){
           queens.add(i);
       }
       
       Collections.shuffle(queens);
       
       for(int i = 0; i < 15; i++){
           int n = queens.remove(0);
           board[n][i] = 1;
       }
       
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               if(board[j][i] == 1) {
                   switch(j){
                       case 10: label = label + "A";
                           break;
                       case 11: label = label + "B";
                           break;
                       case 12: label = label + "C";
                           break;
                       case 13: label = label + "D";
                           break;
                       case 14: label = label + "E";
                           break;
                       default: label = label + j;
                           break;
                   }
                   
               }
           }
       }
   }
   
   //for genetic algorithm, given a string that represents the position of the 
   //queen, generate a board with it
   public queenPuzzle(String s){
       label = s;
       age = 0;
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               board[i][j] = 0;
           }
       }
       
       for(int i = 0; i < 15; i++){
           int test;
           char c = s.charAt(i);
           switch(c){
               case 'A': test = 10;
                   break;
               case 'B': test = 11;
                   break;
               case 'C': test = 12;
                   break;
               case 'D': test = 13;
                   break;
               case 'E': test = 14;
                   break;
               default: test = Character.getNumericValue(s.charAt(i));
           }
           board[test][i] = 1;
       }
   }
   public String getLabel(){
       return label;
   }
   
   //for testing purposes, lines up a queen in a single row
   public queenPuzzle(int n){
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               board[i][j] = 0;
               if(i == 5) board[i][j] = 1;
           }
       }
   }
   //Prints out the board in a readable format
   public void print(){
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               System.out.print(board[i][j] + " ");
           }
           System.out.println();
       }
   }
   
   //Finds the number of pair of attacking queens
   public int attackingQs(){
       int nQueens = 0; 
       
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               if(board[j][i] == 1){
                   nQueens = nQueens + findAdjacent(j, i);
               }
           }
       }
       return nQueens;
   }
   
   //Checks if the board is the goal state or not
   public boolean isSolved(){
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               if(board[j][i] == 1){
                   if(findAdjacent(i, j) > 0) return false;
               }
           }
       }
       return true;
   }   
   
   public int[][] getBoard(){
       return board;
   }
   
   public boolean equals(queenPuzzle q){
       int [][] qBoard = q.getBoard();
       for(int i = 0; i < 15; i++){
           for(int j = 0; j < 15; j++){
               if(this.board[i][j] != qBoard[i][j]) return false; 
           }
       }
       return true;
   }
   
   //Selects a board from a population based on a percentage generated by the fitness function
   //Fitness function is number of non-attacking queen
   public queenPuzzle randomSelection(queenPuzzle[] population, int pop){
       double [] fitVal = new double[pop]; double fitTotal = 0;
       for(int i = 0; i < pop; i++){
           fitVal[i] = 105 - population[i].attackingQs();
           fitTotal = fitTotal + fitVal[i];
       }
       
       double fitPercent = 0;
       double random = Math.random();
       for(int i = 0; i < pop; i++){
           fitPercent = fitPercent + fitVal[i]/fitTotal;
           if(random < fitPercent && age < 3){
               return population[i];
           }
       }
       System.out.println("dsadad");
       return null;
   }
   //Performs the genetic algorithm
   public queenPuzzle genetic(){
       queenPuzzle [] parents = new queenPuzzle[999];
       int population = 15;
       for(int i = 0; i < 15; i++){
           parents[i] = new queenPuzzle();
       }
       while(population < 200){
           int newPop = population;
           for(int i = 0; i < population; i++){
               queenPuzzle test1 = randomSelection(parents, population);
               queenPuzzle test2;
               //To ensure that it does not cross-over with itself
               do{
                   test2 = randomSelection(parents, population);
               }
               while(!test2.equals(test1));
               
               queenPuzzle child = new queenPuzzle(reproduce(test1, test2));
               double chance = Math.random();
               if(chance < 0.1) child.mutate();
               parents[newPop] = child;
               
               newPop++;
           }
           population = newPop;
       }
       
       int objVal = 9999; //Number of attacking queens
       int arrayPos = 0; //Position of the board in the parents array
       //Find the board with the least number of attacking queens
       for(int i = 0; i < population; i++){
           if(parents[i].attackingQs() < objVal){
               arrayPos = i;
               objVal = parents[i].attackingQs();
           }
       }
       return parents[arrayPos];
   }
   
   //does the mutation by changing the position of one queen randomly
   public void mutate(){
       Random randomInt = new Random();
       int posX = randomInt.nextInt(14);
       int posY = randomInt.nextInt(14);
       clearColumn(posY);
       board[posX][posY] = 1;
   }
   
   //Does the cross-over portion of the algorithm
   public String reproduce(queenPuzzle x, queenPuzzle y){
       Random randomInt = new Random();
       int n = x.getLabel().length();
       int c = randomInt.nextInt(n-2) + 1;
       String s = x.getLabel().substring(0, c) + y.getLabel().substring(c, n);
       return s;
   }
   
   //Performs the hill cimbing steepest ascent algorithm
   public int hillClimb(){
       int tempBoard [][] = new int [15][15];
       int yTemp; int curState = this.attackingQs(); int steps = 0;
       
       while(true){
            steps++;
            for(int i = 0; i < 15; i++){
                yTemp = this.clearColumn(i);
                for(int j = 0; j < 15; j++){
                    board[j][i] = 1;
                    tempBoard[j][i] = this.attackingQs();
                    board[j][i] = 0;
                }
                board[yTemp][i] = 1;
            }
            
            int temp = curState;
            for(int i = 0; i< 15; i++){
                for(int j = 0; j < 15; j++){
                    if(tempBoard[i][j] < temp){ 
                        temp = tempBoard[i][j];
                        this.clearColumn(j);
                        board[i][j] = 1;
                    }
                }
            }
            if(temp >= curState || temp == 0) break;
            else curState = temp; 
       }
       
       return steps;
   }
   
   //Clears the column and returns the position of the queen in that column
   public int clearColumn(int y){
       int qPos = 0;
       for(int i = 0; i < 15; i++){
           if(board[i][y] == 1) qPos = i;
           board[i][y] = 0;
       }
       return qPos;
   }
   
   //Finds the number of attacking pair of queens on the right side
   public int findAdjacent(int x, int y){
       int nQueens = 0;
       int xTest1 = x;
       int xTest2 = x;
       int yTest = (y + 1);
       //Check for right side and right diagonals both up and down
       for(int i = yTest; i < 15; i++){
           if(board[x][i] == 1) nQueens++;
           xTest1++;
           if(xTest1 < 15)
                if(board[xTest1][i] == 1 )nQueens++;
           xTest2--;
           if(xTest2 > -1)
               if(board[xTest2][i] == 1 ) nQueens++;
       }       
       return nQueens;
   }
}
